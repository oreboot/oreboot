use core::mem::size_of;
use types::bit;

pub const EC_CMD_HOST_EVENT_GET_B: u16 = 0x0087;
pub const EC_CMD_HOST_EVENT_GET_SMI_MASK: u16 = 0x0088;
pub const EC_CMD_HOST_EVENT_GET_SCI_MASK: u16 = 0x0089;
pub const EC_CMD_HOST_EVENT_GET_WAKE_MASK: u16 = 0x008D;

pub const EC_CMD_GET_BOARD_VERSION: u16 = 0x0006;
pub const EC_CMD_HOST_EVENT_SET_SMI_MASK: u16 = 0x008A;
pub const EC_CMD_HOST_EVENT_SET_SCI_MASK: u16 = 0x008B;
pub const EC_CMD_HOST_EVENT_CLEAR: u16 = 0x008C;
pub const EC_CMD_HOST_EVENT_SET_WAKE_MASK: u16 = 0x008E;
pub const EC_CMD_HOST_EVENT_CLEAR_B: u16 = 0x008F;

pub const EC_CMD_GET_FEATURES: u16 = 0x000D;
pub const EC_CMD_GET_CROS_BOARD_INFO: u16 = 0x011F;
pub const EC_CMD_GET_NEXT_EVENT: u16 = 0x0067;

pub const EC_CMD_ACPI_QUERY_EVENT: u16 = 0x0084;

pub const EC_LPC_ADDR_ACPI_CMD: u16 = 0x66;
pub const EC_LPC_ADDR_ACPI_DATA: u16 = 0x62;
pub const EC_LPC_ADDR_MEMMAP: u16 = 0x900;
pub const EC_LPC_CMDR_DATA: u16 = bit(0) as u16;
pub const EC_LPC_CMDR_PENDING: u16 = bit(1) as u16;
pub const EC_LPC_CMDR_BUSY: u16 = bit(2) as u16;
pub const EC_MEMMAP_SWITCHES: u16 = 0x30;
pub const EC_HOST_CMD_REGION_SIZE: usize = 0x80;
pub const EC_HOST_CMD_REGION0: u16 = 0x0800;
/// ACPI IO buffer max is 255 bytes
pub const EC_MEMMAP_SIZE: usize = 255;

pub const fn bit_ull(nr: u64) -> u64 {
    1 << nr
}

pub const fn ec_host_event_mask(event_code: u32) -> u64 {
    bit_ull((event_code as u64) - 1)
}

pub const fn ec_feature_mask_0(event_code: u32) -> u64 {
    bit((event_code as u64) % 32)
}

pub const fn ec_feature_mask_1(event_code: u32) -> u64 {
    bit((event_code as u64) - 32)
}

#[repr(C)]
#[derive(Clone, Copy, PartialEq)]
pub enum HostEventCode {
    None = 0,
    LidClosed = 1,
    LidOpen = 2,
    PowerButton = 3,
    AcConnected = 4,
    AcDisconnected = 5,
    BatteryLow = 6,
    BatteryCritical = 7,
    Battery = 8,
    ThermalThreshold = 9,
    /* Event generated by a device attached to the EC */
    Device = 10,
    Thermal = 11,
    UsbCharger = 12,
    KeyPressed = 13,
    /// EC has finished initializing the host interface.  The host can check
    /// for this event following sending a EC_CMD_REBOOT_EC command to
    /// determine when the EC is ready to accept subsequent commands.
    InterfaceReady = 14,
    /// Keyboard recovery combo has been pressed
    KeyboardRecovery = 15,
    /// Shutdown due to thermal overload
    ThermalShutdown = 16,
    /// Shutdown due to battery level too low
    BatteryShutdown = 17,
    /// Suggest that the AP throttle itself
    ThrottleStart = 18,
    /// Suggest that the AP resume normal speed
    ThrottleStop = 19,
    /// Hang detect logic detected a hang and host event timeout expired
    HangDetect = 20,
    /// Hang detect logic detected a hang and warm rebooted the AP
    HangReboot = 21,
    /// PD MCU triggering host event
    PdMcu = 22,
    /// Battery Status flags have changed
    BatteryStatus = 23,
    /// EC encountered a panic, triggering a reset
    Panic = 24,
    /// Keyboard fastboot combo has been pressed
    KeyboardFastboot = 25,
    /// EC RTC event occurred
    Rtc = 26,
    /// Emulate MKBP event
    Mkbp = 27,
    /// EC desires to change state of host-controlled USB mux
    UsbMux = 28,
    /// The device has changed "modes". This can be one of the following:
    ///
    /// - TABLET/LAPTOP mode
    /// - detachable base attach/detach event
    ModeChange = 29,
    /// Keyboard recovery combo with hardware reinitialization
    KeyboardRecoveryHWReinit = 30,
    /// WoV
    Wov = 31,
    /// The high bit of the event mask is not used as a host event code.  If
    /// it reads back as set, then the entire event mask should be
    /// considered invalid by the host.  This can happen when reading the
    /// raw event status via EC_MEMMAP_HOST_EVENTS but the LPC interface is
    /// not initialized on the EC, or improperly configured on the host.
    Invalid = 32,
}

impl From<u8> for HostEventCode {
    fn from(b: u8) -> Self {
        match b {
            0 => Self::None,
            1 => Self::LidClosed,
            2 => Self::LidOpen,
            3 => Self::PowerButton,
            4 => Self::AcConnected,
            5 => Self::AcDisconnected,
            6 => Self::BatteryLow,
            7 => Self::BatteryCritical,
            8 => Self::Battery,
            9 => Self::ThermalThreshold,
            10 => Self::Device,
            11 => Self::Thermal,
            12 => Self::UsbCharger,
            13 => Self::KeyPressed,
            14 => Self::InterfaceReady,
            15 => Self::KeyboardRecovery,
            16 => Self::ThermalShutdown,
            17 => Self::BatteryShutdown,
            18 => Self::ThrottleStart,
            19 => Self::ThrottleStop,
            20 => Self::HangDetect,
            21 => Self::HangReboot,
            22 => Self::PdMcu,
            23 => Self::BatteryStatus,
            24 => Self::Panic,
            25 => Self::KeyboardFastboot,
            26 => Self::Rtc,
            27 => Self::Mkbp,
            28 => Self::UsbMux,
            29 => Self::ModeChange,
            30 => Self::KeyboardRecoveryHWReinit,
            31 => Self::Wov,
            32 => Self::Invalid,
            _ => Self::Invalid,
        }
    }
}

/// Supported features
#[repr(C)]
#[derive(Clone, Copy, PartialEq)]
pub enum EcFeatureCode {
    /// This image contains a limited set of features. Another image
    /// in RW partition may support more features.
    Limited = 0,
    /// Commands for probing/reading/writing/erasing the flash in the
    /// EC are present.
    Flash = 1,
    /// Can control the fan speed directly.
    PwmFan = 2,
    /// Can control the intensity of the keyboard backlight.
    PwmKeyb = 3,
    /// Support Google lightbar, introduced on Pixel.
    Lightbar = 4,
    /// Control of LEDs
    Led = 5,
    /// Exposes an interface to control gyro and sensors.
    /// The host goes through the EC to access these sensors.
    /// In addition, the EC may provide composite sensors, like lid angle.
    MotionSense = 6,
    /// The keyboard is controlled by the EC
    Keyb = 7,
    /// The AP can use part of the EC flash as persistent storage.
    Pstore = 8,
    /// The EC monitors BIOS port 80h, and can return POST codes.
    Port80 = 9,
    /// Thermal management: include TMP specific commands.
    /// Higher level than direct fan control.
    Thermal = 10,
    /// Can switch the screen backlight on/off
    BklightSwitch = 11,
    /// Can switch the wifi module on/off
    WifiSwitch = 12,
    /// Monitor host events, through for example SMI or SCI
    HostEvents = 13,
    /// The EC exposes GPIO commands to control/monitor connected devices.
    Gpio = 14,
    /// The EC can send i2c messages to downstream devices.
    I2c = 15,
    /// Command to control charger are included
    Charger = 16,
    /// Simple battery support.
    Battery = 17,
    /// Support Smart battery protocol
    /// (Common Smart Battery System Interface Specification)
    SmartBattery = 18,
    /// EC can detect when the host hangs
    HangDetect = 19,
    /// Report power information, for pit only
    Pmu = 20,
    /// Another Cros EC device is present downstream of this one
    SubMcu = 21,
    /// Support USB Power delivery (PD) commands
    UsbPd = 22,
    /// Control USB multiplexer, for audio through USB port for instance.
    UsbMux = 23,
    /// Motion Sensor code has an internal software FIFO
    MotionSenseFifo = 24,
    /// Support temporary secure vstore
    Vstore = 25,
    /// EC decides on USB-C SS mux state, muxes configured by host
    UsbcSsMuxVirtual = 26,
    /// EC has RTC feature that can be controlled by host commands
    Rtc = 27,
    /// The MCU exposes a Fingerprint sensor
    Fingerprint = 28,
    /// The MCU exposes a Touchpad
    Touchpad = 29,
    /// The MCU has RWSIG task enabled
    Rwsig = 30,
    /// EC has device events support
    DeviceEvent = 31,
    /// EC supports the unified wake masks for LPC/eSPI systems
    UnifiedWakeMasks = 32,
    /// EC supports 64-bit host events
    HostEvent64 = 33,
    /// EC runs code in RAM (not in place, a.k.a. XIP)
    ExecInRam = 34,
    /// EC supports CEC commands
    Cec = 35,
    /// EC supports tight sensor timestamping.
    MotionSenseTightTimestamps = 36,
    /// EC supports tablet mode detection aligned to Chrome and allows
    /// setting of threshold by host command using
    /// MOTIONSENSE_CMD_TABLET_MODE_LID_ANGLE.
    RefinedTabletModeHysteresis = 37,
    /// Early Firmware Selection ver.2. Enabled by CONFIG_VBOOT_EFS2.
    /// Note this is a RO feature. So, a query (EC_CMD_GET_FEATURES) should
    /// be sent to RO to be precise.
    Efs2 = 38,
    /// The MCU is a System Companion Processor (SCP).
    Scp = 39,
    /// The MCU is an Integrated Sensor Hub
    Ish = 40,
    /// New TCPMv2 TYPEC_ prefaced commands supported
    TypecCmd = 41,
    /// The EC will wait for direction from the AP to enter Type-C alternate
    /// modes or USB4.
    TypecRequireApModeEntry = 42,
    /// The EC will wait for an acknowledge from the AP after setting the
    /// mux.
    TypecMuxRequireApAck = 43,
    /// The EC supports entering and residing in S4.
    S4Residency = 44,
    /// The EC supports the AP directing mux sets for the board.
    TypecApMuxSet = 45,
}

#[repr(C)]
#[derive(Clone, Copy, PartialEq)]
pub enum EcHostEventAction {
    /// params.value is ignored. Value of mask_type populated
    /// in response.value
    Get,
    /// Bits in params.value are set
    Set,
    /// Bits in params.value are cleared
    Clear,
}

#[repr(C)]
#[derive(Clone, Copy, PartialEq)]
pub enum EcHostEventMaskType {
    /// Main host event copy
    Main,
    /// Copy B of host events
    B,
    /// SCI Mask
    SciMask,
    /// SMI Mask
    SmiMask,
    /// Mask of events that should be always reported in hostevents
    AlwaysReportMask,
    /// Active wake mask
    ActiveWakeMask,
    /// Lazy wake mask for S0ix
    LazyWakeMaskS0ix,
    /// Lazy wake mask for S3
    LazyWakeMaskS3,
    /// Lazy wake mask for S5
    LazyWakeMaskS5,
}

pub const EC_CMD_HOST_EVENT: u16 = 0x00A4;

#[repr(C, align(2))]
pub struct ECResponseBoardVersion {
    board_version: u16,
}

impl ECResponseBoardVersion {
    pub fn new() -> Self {
        Self { board_version: 0 }
    }

    pub fn board_version(&self) -> u16 {
        self.board_version
    }

    pub fn len(&self) -> usize {
        core::mem::size_of::<ECResponseBoardVersion>()
    }

    pub fn as_bytes(&self) -> [u8; 2] {
        self.board_version.to_le_bytes()
    }
}

#[repr(C, align(4))]
pub struct EcParamsHostEvent {
    /// Action requested by host - one of enum ec_host_event_action.
    pub action: EcHostEventAction,
    /// Mask type that the host requested the action on - one of
    /// enum ec_host_event_mask_type.
    pub mask_type: EcHostEventMaskType,
    /// Set to 0, ignore on read
    pub reserved: u16,
    /// Value to be used in case of set operations.
    pub value: u64,
}

impl EcParamsHostEvent {
    pub fn as_ptr(&self) -> *const Self {
        self as *const Self
    }

    pub fn as_byte_ptr(&self) -> *const u8 {
        self.as_ptr() as *const u8
    }

    pub const fn len(&self) -> usize {
        size_of::<Self>()
    }
}

#[repr(C, align(4))]
pub struct EcResponseHostEvent {
    /// Mask value in case of get operation
    pub value: u64,
}

impl EcResponseHostEvent {
    pub const fn new() -> Self {
        Self { value: 0 }
    }

    pub fn as_ptr(&self) -> *const Self {
        self as *const Self
    }

    pub fn as_mut_ptr(&mut self) -> *mut Self {
        self as *mut Self
    }

    pub fn as_mut_byte_ptr(&mut self) -> *mut u8 {
        self.as_mut_ptr() as *mut u8
    }

    pub fn as_byte_ptr(&self) -> *const u8 {
        self.as_ptr() as *const u8
    }

    pub const fn len(&self) -> usize {
        size_of::<Self>()
    }
}

#[repr(C, align(4))]
pub struct EcResponseGetFeatures {
    pub flags: [u32; 2],
}

impl EcResponseGetFeatures {
    pub const fn new() -> Self {
        Self { flags: [0; 2] }
    }

    pub fn as_ptr(&self) -> *const Self {
        self as *const Self
    }

    pub fn as_mut_ptr(&mut self) -> *mut Self {
        self as *mut Self
    }

    pub fn as_mut_byte_ptr(&mut self) -> *mut u8 {
        self.as_mut_ptr() as *mut u8
    }

    pub fn as_byte_ptr(&self) -> *const u8 {
        self.as_ptr() as *const u8
    }

    pub const fn len(&self) -> usize {
        size_of::<Self>()
    }
}

#[repr(C, align(4))]
pub struct EcParamsHostEventMask {
    pub mask: u32,
}

impl EcParamsHostEventMask {
    pub const fn new() -> Self {
        Self { mask: 0 }
    }

    pub fn as_ptr(&self) -> *const Self {
        self as *const Self
    }

    pub fn as_mut_ptr(&mut self) -> *mut Self {
        self as *mut Self
    }

    pub fn as_mut_byte_ptr(&mut self) -> *mut u8 {
        self.as_mut_ptr() as *mut u8
    }

    pub fn as_byte_ptr(&self) -> *const u8 {
        self.as_ptr() as *const u8
    }

    pub const fn len(&self) -> usize {
        size_of::<Self>()
    }
}

#[repr(C, align(4))]
pub struct EcResponseHostEventMask {
    pub mask: u32,
}

impl EcResponseHostEventMask {
    pub const fn new() -> Self {
        Self { mask: 0 }
    }

    pub fn as_ptr(&self) -> *const Self {
        self as *const Self
    }

    pub fn as_mut_ptr(&mut self) -> *mut Self {
        self as *mut Self
    }

    pub fn as_mut_byte_ptr(&mut self) -> *mut u8 {
        self.as_mut_ptr() as *mut u8
    }

    pub fn as_byte_ptr(&self) -> *const u8 {
        self.as_ptr() as *const u8
    }

    pub const fn len(&self) -> usize {
        size_of::<Self>()
    }
}

#[repr(C)]
#[derive(Clone, Copy)]
pub enum CbiDataTag {
    /// uint32_t or smaller
    BoardVersion = 0,
    /// uint32_t or smaller
    OemId = 1,
    /// uint32_t or smaller
    SkuId = 2,
    /// variable length ascii, nul terminated.
    DramPartNum = 3,
    /// variable length ascii, nul terminated.
    OemName = 4,
    /// uint32_t or smaller
    ModelId = 5,
    /// uint32_t bit field
    FwConfig = 6,
    /// uint32_t or smaller
    PcbSupplier = 7,
    // Second Source Factory Cache
    /// uint32_t bit field
    TagSsfc = 8,
    /// uint64_t or smaller
    TagReworkId = 9,
    TagCount,
    Invalid,
}

impl From<u32> for CbiDataTag {
    fn from(t: u32) -> Self {
        match t {
            0 => Self::BoardVersion,
            1 => Self::OemId,
            2 => Self::SkuId,
            3 => Self::DramPartNum,
            4 => Self::OemName,
            5 => Self::ModelId,
            6 => Self::FwConfig,
            7 => Self::PcbSupplier,
            8 => Self::TagSsfc,
            9 => Self::TagReworkId,
            10 => Self::TagCount,
            _ => Self::Invalid,
        }
    }
}

#[repr(C, align(4))]
#[derive(Clone, Copy)]
pub struct EcParamsGetCbi {
    tag: CbiDataTag,
    flag: u32,
}

impl EcParamsGetCbi {
    pub const fn new() -> Self {
        Self {
            tag: CbiDataTag::BoardVersion,
            flag: 0,
        }
    }

    pub const fn create(tag: CbiDataTag, flag: u32) -> Self {
        Self { tag, flag }
    }

    pub fn tag(&self) -> CbiDataTag {
        self.tag
    }

    pub fn flag(&self) -> u32 {
        self.flag
    }

    pub fn as_byte_ptr(&self) -> *const u8 {
        self as *const _ as *const u8
    }

    pub fn as_byte_ptr_mut(&mut self) -> *mut u8 {
        self as *mut _ as *mut u8
    }

    pub fn len(&self) -> usize {
        size_of::<Self>()
    }
}

/// Note: used in EcResponseGetNextData
#[repr(C)]
#[derive(Clone, Copy)]
pub struct EcResponseMotionSenseFifoInfo {
    /// Size of the fifo
    size: u16,
    /// Amount of space used in the fifo
    count: u16,
    /// Timestamp recorded in us.
    /// aka accurate timestamp when host event was triggered.
    timestamp: u32,
    /// Total amount of vector lost
    total_lost: u16,
    /// Lost events since the last fifo_info, per sensors
    lost: [u16; 0],
}

#[repr(C)]
#[derive(Clone, Copy)]
pub struct SensorFifo {
    reserved: [u8; 3],
    info: EcResponseMotionSenseFifoInfo,
}

/// Events from CEC to AP
#[repr(C)]
#[derive(Clone, Copy)]
pub enum MkbpCecEvent {
    SendOk = bit(0) as isize,
    SendFailed = bit(1) as isize,
}

#[repr(C, align(1))]
#[derive(Clone, Copy)]
pub union EcResponseGetNextData {
    key_matrix: [u8; 13],
    host_event: u32,
    host_event64: u64,
    sensor_fifo: SensorFifo,
    buttons: u32,
    switches: u32,
    fp_events: u32,
    sysrq: u32,
    cec_events: MkbpCecEvent,
}

impl EcResponseGetNextData {
    pub const fn new() -> Self {
        Self { host_event: 0 }
    }
}

#[repr(C, align(1))]
#[derive(Clone, Copy)]
pub struct EcResponseGetNextEvent {
    event_type: u8,
    data: EcResponseGetNextData,
}

impl EcResponseGetNextEvent {
    pub const fn new() -> Self {
        Self {
            event_type: 0,
            data: EcResponseGetNextData::new(),
        }
    }

    pub fn event_type(&self) -> u8 {
        self.event_type
    }

    pub fn data(&self) -> &EcResponseGetNextData {
        &self.data
    }

    pub fn as_byte_ptr(&self) -> *const u8 {
        self as *const _ as *const u8
    }

    pub fn as_byte_ptr_mut(&mut self) -> *mut u8 {
        self as *mut _ as *mut u8
    }

    pub fn len(&self) -> usize {
        size_of::<Self>()
    }
}
