use core::mem::size_of;
use types::bit;

pub const EC_CMD_HOST_EVENT_GET_B: u16 = 0x0087;
pub const EC_CMD_HOST_EVENT_GET_SMI_MASK: u16 = 0x0088;
pub const EC_CMD_HOST_EVENT_GET_SCI_MASK: u16 = 0x0089;
pub const EC_CMD_HOST_EVENT_GET_WAKE_MASK: u16 = 0x008D;

pub const EC_CMD_GET_BOARD_VERSION: u16 = 0x0006;
pub const EC_CMD_HOST_EVENT_SET_SMI_MASK: u16 = 0x008A;
pub const EC_CMD_HOST_EVENT_SET_SCI_MASK: u16 = 0x008B;
pub const EC_CMD_HOST_EVENT_CLEAR: u16 = 0x008C;
pub const EC_CMD_HOST_EVENT_SET_WAKE_MASK: u16 = 0x008E;
pub const EC_CMD_HOST_EVENT_CLEAR_B: u16 = 0x008F;

pub const EC_CMD_GET_FEATURES: u16 = 0x000D;

pub fn bit_ull(nr: u64) -> u64 {
    1 << nr
}

pub fn ec_host_event_mask(event_code: u32) -> u64 {
    bit_ull((event_code as u64) - 1)
}

pub fn ec_feature_mask_0(event_code: u32) -> u64 {
    bit((event_code as u64) % 32)
}

pub fn ec_feature_mask_1(event_code: u32) -> u64 {
    bit((event_code as u64) - 32)
}

#[repr(C)]
pub enum HostEventCode {
    None = 0,
    LidClosed = 1,
    LidOpen = 2,
    PowerButton = 3,
    ACConnected = 4,
    ACDisconnected = 5,
    BatteryLow = 6,
    BatteryCritical = 7,
    Battery = 8,
    ThermalThreshold = 9,
    /* Event generated by a device attached to the EC */
    Device = 10,
    Thermal = 11,
    USBCharger = 12,
    KeyPressed = 13,
    /// EC has finished initializing the host interface.  The host can check
    /// for this event following sending a EC_CMD_REBOOT_EC command to
    /// determine when the EC is ready to accept subsequent commands.
    InterfaceReady = 14,
    /// Keyboard recovery combo has been pressed
    KeyboardRecovery = 15,
    /// Shutdown due to thermal overload
    ThermalShutdown = 16,
    /// Shutdown due to battery level too low
    BatteryShutdown = 17,
    /// Suggest that the AP throttle itself
    ThrottleStart = 18,
    /// Suggest that the AP resume normal speed
    ThrottleStop = 19,
    /// Hang detect logic detected a hang and host event timeout expired
    HangDetect = 20,
    /// Hang detect logic detected a hang and warm rebooted the AP
    HangReboot = 21,
    /// PD MCU triggering host event
    PDMcu = 22,
    /// Battery Status flags have changed
    BatteryStatus = 23,
    /// EC encountered a panic, triggering a reset
    Panic = 24,
    /// Keyboard fastboot combo has been pressed
    KeyboardFastboot = 25,
    /// EC RTC event occurred
    RTC = 26,
    /// Emulate MKBP event
    MKBP = 27,
    /// EC desires to change state of host-controlled USB mux
    USBMux = 28,
    /// The device has changed "modes". This can be one of the following:
    ///
    /// - TABLET/LAPTOP mode
    /// - detachable base attach/detach event
    ModeChange = 29,
    /// Keyboard recovery combo with hardware reinitialization
    KeyboardRecoveryHWReinit = 30,
    /// WoV
    WOV = 31,
    /// The high bit of the event mask is not used as a host event code.  If
    /// it reads back as set, then the entire event mask should be
    /// considered invalid by the host.  This can happen when reading the
    /// raw event status via EC_MEMMAP_HOST_EVENTS but the LPC interface is
    /// not initialized on the EC, or improperly configured on the host.
    Invalid = 32,
}

/// Supported features
#[repr(C)]
pub enum EcFeatureCode {
    /// This image contains a limited set of features. Another image
    /// in RW partition may support more features.
    Limited = 0,
    /// Commands for probing/reading/writing/erasing the flash in the
    /// EC are present.
    Flash = 1,
    /// Can control the fan speed directly.
    PwmFan = 2,
    /// Can control the intensity of the keyboard backlight.
    PwmKeyb = 3,
    /// Support Google lightbar, introduced on Pixel.
    Lightbar = 4,
    /// Control of LEDs
    Led = 5,
    /// Exposes an interface to control gyro and sensors.
    /// The host goes through the EC to access these sensors.
    /// In addition, the EC may provide composite sensors, like lid angle.
    MotionSense = 6,
    /// The keyboard is controlled by the EC
    Keyb = 7,
    /// The AP can use part of the EC flash as persistent storage.
    Pstore = 8,
    /// The EC monitors BIOS port 80h, and can return POST codes.
    Port80 = 9,
    /// Thermal management: include TMP specific commands.
    /// Higher level than direct fan control.
    Thermal = 10,
    /// Can switch the screen backlight on/off
    BklightSwitch = 11,
    /// Can switch the wifi module on/off
    WifiSwitch = 12,
    /// Monitor host events, through for example SMI or SCI
    HostEvents = 13,
    /// The EC exposes GPIO commands to control/monitor connected devices.
    Gpio = 14,
    /// The EC can send i2c messages to downstream devices.
    I2c = 15,
    /// Command to control charger are included
    Charger = 16,
    /// Simple battery support.
    Battery = 17,
    /// Support Smart battery protocol
    /// (Common Smart Battery System Interface Specification)
    SmartBattery = 18,
    /// EC can detect when the host hangs
    HangDetect = 19,
    /// Report power information, for pit only
    Pmu = 20,
    /// Another Cros EC device is present downstream of this one
    SubMcu = 21,
    /// Support USB Power delivery (PD) commands
    UsbPd = 22,
    /// Control USB multiplexer, for audio through USB port for instance.
    UsbMux = 23,
    /// Motion Sensor code has an internal software FIFO
    MotionSenseFifo = 24,
    /// Support temporary secure vstore
    Vstore = 25,
    /// EC decides on USB-C SS mux state, muxes configured by host
    UsbcSsMuxVirtual = 26,
    /// EC has RTC feature that can be controlled by host commands
    Rtc = 27,
    /// The MCU exposes a Fingerprint sensor
    Fingerprint = 28,
    /// The MCU exposes a Touchpad
    Touchpad = 29,
    /// The MCU has RWSIG task enabled
    Rwsig = 30,
    /// EC has device events support
    DeviceEvent = 31,
    /// EC supports the unified wake masks for LPC/eSPI systems
    UnifiedWakeMasks = 32,
    /// EC supports 64-bit host events
    HostEvent64 = 33,
    /// EC runs code in RAM (not in place, a.k.a. XIP)
    ExecInRam = 34,
    /// EC supports CEC commands
    Cec = 35,
    /// EC supports tight sensor timestamping.
    MotionSenseTightTimestamps = 36,
    /// EC supports tablet mode detection aligned to Chrome and allows
    /// setting of threshold by host command using
    /// MOTIONSENSE_CMD_TABLET_MODE_LID_ANGLE.
    RefinedTabletModeHysteresis = 37,
    /// Early Firmware Selection ver.2. Enabled by CONFIG_VBOOT_EFS2.
    /// Note this is a RO feature. So, a query (EC_CMD_GET_FEATURES) should
    /// be sent to RO to be precise.
    Efs2 = 38,
    /// The MCU is a System Companion Processor (SCP).
    Scp = 39,
    /// The MCU is an Integrated Sensor Hub
    Ish = 40,
    /// New TCPMv2 TYPEC_ prefaced commands supported
    TypecCmd = 41,
    /// The EC will wait for direction from the AP to enter Type-C alternate
    /// modes or USB4.
    TypecRequireApModeEntry = 42,
    /// The EC will wait for an acknowledge from the AP after setting the
    /// mux.
    TypecMuxRequireApAck = 43,
    /// The EC supports entering and residing in S4.
    S4Residency = 44,
    /// The EC supports the AP directing mux sets for the board.
    TypecApMuxSet = 45,
}

#[repr(C)]
#[derive(Clone, Copy, PartialEq)]
pub enum EcHostEventAction {
    /// params.value is ignored. Value of mask_type populated
    /// in response.value
    Get,
    /// Bits in params.value are set
    Set,
    /// Bits in params.value are cleared
    Clear,
}

#[repr(C)]
#[derive(Clone, Copy, PartialEq)]
pub enum EcHostEventMaskType {
    /// Main host event copy
    Main,
    /// Copy B of host events
    B,
    /// SCI Mask
    SciMask,
    /// SMI Mask
    SmiMask,
    /// Mask of events that should be always reported in hostevents
    AlwaysReportMask,
    /// Active wake mask
    ActiveWakeMask,
    /// Lazy wake mask for S0ix
    LazyWakeMaskS0ix,
    /// Lazy wake mask for S3
    LazyWakeMaskS3,
    /// Lazy wake mask for S5
    LazyWakeMaskS5,
}

pub const EC_CMD_HOST_EVENT: u16 = 0x00A4;

#[repr(C, align(2))]
pub struct ECResponseBoardVersion {
    board_version: u16,
}

impl ECResponseBoardVersion {
    pub fn new() -> Self {
        Self { board_version: 0 }
    }

    pub fn board_version(&self) -> u16 {
        self.board_version
    }

    pub fn len(&self) -> usize {
        core::mem::size_of::<ECResponseBoardVersion>()
    }

    pub fn as_bytes(&self) -> [u8; 2] {
        self.board_version.to_le_bytes()
    }
}

#[repr(C, align(4))]
pub struct EcParamsHostEvent {
    /// Action requested by host - one of enum ec_host_event_action.
    pub action: EcHostEventAction,
    /// Mask type that the host requested the action on - one of
    /// enum ec_host_event_mask_type.
    pub mask_type: EcHostEventMaskType,
    /// Set to 0, ignore on read
    pub reserved: u16,
    /// Value to be used in case of set operations.
    pub value: u64,
}

impl EcParamsHostEvent {
    pub fn as_ptr(&self) -> *const Self {
        self as *const Self
    }

    pub fn as_byte_ptr(&self) -> *const u8 {
        self.as_ptr() as *const u8
    }

    pub const fn len(&self) -> usize {
        size_of::<Self>()
    }
}

#[repr(C, align(4))]
pub struct EcResponseHostEvent {
    /// Mask value in case of get operation
    pub value: u64,
}

impl EcResponseHostEvent {
    pub const fn new() -> Self {
        Self { value: 0 }
    }

    pub fn as_ptr(&self) -> *const Self {
        self as *const Self
    }

    pub fn as_mut_ptr(&mut self) -> *mut Self {
        self as *mut Self
    }

    pub fn as_mut_byte_ptr(&mut self) -> *mut u8 {
        self.as_mut_ptr() as *mut u8
    }

    pub fn as_byte_ptr(&self) -> *const u8 {
        self.as_ptr() as *const u8
    }

    pub const fn len(&self) -> usize {
        size_of::<Self>()
    }
}

#[repr(C, align(4))]
pub struct EcResponseGetFeatures {
    pub flags: [u32; 2],
}

impl EcResponseGetFeatures {
    pub const fn new() -> Self {
        Self { flags: [0; 2] }
    }

    pub fn as_ptr(&self) -> *const Self {
        self as *const Self
    }

    pub fn as_mut_ptr(&mut self) -> *mut Self {
        self as *mut Self
    }

    pub fn as_mut_byte_ptr(&mut self) -> *mut u8 {
        self.as_mut_ptr() as *mut u8
    }

    pub fn as_byte_ptr(&self) -> *const u8 {
        self.as_ptr() as *const u8
    }

    pub const fn len(&self) -> usize {
        size_of::<Self>()
    }
}

#[repr(C, align(4))]
pub struct EcParamsHostEventMask {
    pub mask: u32,
}

impl EcParamsHostEventMask {
    pub const fn new() -> Self {
        Self { mask: 0 }
    }

    pub fn as_ptr(&self) -> *const Self {
        self as *const Self
    }

    pub fn as_mut_ptr(&mut self) -> *mut Self {
        self as *mut Self
    }

    pub fn as_mut_byte_ptr(&mut self) -> *mut u8 {
        self.as_mut_ptr() as *mut u8
    }

    pub fn as_byte_ptr(&self) -> *const u8 {
        self.as_ptr() as *const u8
    }

    pub const fn len(&self) -> usize {
        size_of::<Self>()
    }
}

#[repr(C, align(4))]
pub struct EcResponseHostEventMask {
    pub mask: u32,
}

impl EcResponseHostEventMask {
    pub const fn new() -> Self {
        Self { mask: 0 }
    }

    pub fn as_ptr(&self) -> *const Self {
        self as *const Self
    }

    pub fn as_mut_ptr(&mut self) -> *mut Self {
        self as *mut Self
    }

    pub fn as_mut_byte_ptr(&mut self) -> *mut u8 {
        self.as_mut_ptr() as *mut u8
    }

    pub fn as_byte_ptr(&self) -> *const u8 {
        self.as_ptr() as *const u8
    }

    pub const fn len(&self) -> usize {
        size_of::<Self>()
    }
}
